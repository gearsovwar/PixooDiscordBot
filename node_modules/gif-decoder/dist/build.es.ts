var w = Object.defineProperty;
var S = (r, t, e) => t in r ? w(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var l = (r, t, e) => (S(r, typeof t != "symbol" ? t + "" : t, e), e);
class I {
  constructor(t, e) {
    l(this, "dataView");
    l(this, "offset");
    l(this, "endianess");
    this.dataView = t, this.offset = 0, this.endianess = e;
  }
  readUint8() {
    const t = this.dataView.getUint8(this.offset);
    return this.offset++, t;
  }
  readUint16() {
    const t = this.dataView.getUint16(this.offset, this.endianess);
    return this.offset += 2, t;
  }
  slice(t, e) {
    return new Uint8Array(this.dataView.buffer, t, e);
  }
  setOffset(t) {
    this.offset = t;
  }
}
class O {
  constructor() {
    l(this, "bitOffset");
    l(this, "byteOffset");
    l(this, "bytes");
    this.bitOffset = 0, this.byteOffset = 0, this.bytes = new Uint8Array();
  }
  setBytes(t) {
    if (this.hasBits(1)) {
      const e = this.bytes.byteLength - this.byteOffset, s = new Uint8Array(e + t.byteLength);
      s.set(this.bytes.slice(this.byteOffset)), s.set(t, e), this.bytes = s, this.byteOffset = 0;
    } else
      this.bitOffset = 0, this.byteOffset = 0, this.bytes = t;
  }
  hasBits(t) {
    return 8 * (this.bytes.byteLength - this.byteOffset) - this.bitOffset > t;
  }
  readBits(t) {
    let e = 0, s = 0;
    for (; s < t; ) {
      const a = Math.min(8 - this.bitOffset, t - s);
      e += (255 >> 8 - a << this.bitOffset & this.bytes[this.byteOffset]) >> this.bitOffset << s, s += a, this.bitOffset += a, this.bitOffset === 8 && (this.bitOffset = 0, this.byteOffset++);
    }
    return e;
  }
}
function m(r) {
  let t = "";
  for (let e = 7; e >= 0; e--)
    t += (r & 1 << e) >> e;
  return t;
}
class k {
  constructor(t) {
    l(this, "stream");
    l(this, "header");
    l(this, "logicScreen");
    l(this, "globalColor");
    l(this, "applications");
    l(this, "comments");
    l(this, "graphControls");
    l(this, "plainTexts");
    l(this, "imgs");
    this.setStream(t), this.setGlobal(), this.setLocal();
  }
  setStream(t) {
    this.stream = new I(t, !0);
  }
  setGlobal() {
    this.header = this.getHeader(), this.logicScreen = this.getLogicScreen();
    const { globalColorTableFlag: t, globalColorTableSize: e } = this.logicScreen.packageField;
    this.globalColor = this.getColor(t, e);
  }
  setLocal() {
    this.plainTexts = [], this.graphControls = [], this.comments = [], this.applications = [], this.imgs = [];
    const { stream: t } = this;
    for (; t.offset < t.dataView.byteLength; ) {
      let e = t.readUint8();
      e === 33 ? this.setExtension() : e === 44 && this.setImg();
    }
  }
  getHeader() {
    let t = "";
    for (let e = 0; e < 6; e++)
      t += String.fromCharCode(this.stream.readUint8());
    return t;
  }
  getLogicScreen() {
    const { stream: t } = this, e = {
      canvasWidth: 0,
      canvasHeight: 0,
      packageField: {
        globalColorTableFlag: 0,
        colorResolution: 0,
        sortFlag: 0,
        globalColorTableSize: 0
      },
      bgColorIndex: 0,
      pxAspectRadio: 0
    };
    e.canvasWidth = t.readUint16(), e.canvasHeight = t.readUint16();
    const s = t.readUint8();
    let a = m(s);
    return e.packageField = {
      globalColorTableFlag: parseInt(a[0], 2),
      colorResolution: parseInt(a.slice(1, 4), 2),
      sortFlag: parseInt(a[4], 2),
      globalColorTableSize: parseInt(a.slice(5, 8), 2)
    }, e.bgColorIndex = t.readUint8(), e.pxAspectRadio = t.readUint8(), e;
  }
  setExtension() {
    const { stream: t } = this;
    switch (t.readUint8()) {
      case 1:
        this.plainTexts.push(this.getPlainText());
        break;
      case 249:
        this.graphControls.push(this.getGraphControl());
        break;
      case 254:
        this.comments.push(this.getComment());
        break;
      case 255:
        this.applications.push(this.getApplication());
        break;
    }
    if (t.readUint8() !== 0)
      throw new Error("EOF \u89E3\u6790\u51FA\u9519\uFF01\uFF01\uFF01");
  }
  setImg() {
    const t = {
      imgScreen: {
        left: 0,
        right: 0,
        width: 0,
        height: 0,
        packageField: {
          localColorTableFlag: 0,
          interlaceFlag: 0,
          sortFlag: 0,
          unUse: 0,
          localColorTableSize: 0
        }
      },
      localColor: [],
      data: {
        colorSpace: "srgb",
        data: new Uint8ClampedArray(),
        height: 0,
        width: 0
      }
    };
    t.imgScreen = this.getImgScreen();
    const { localColorTableFlag: e, localColorTableSize: s } = t.imgScreen.packageField;
    t.localColor = this.getColor(e, s), t.data = this.getImgData(t.imgScreen, t.localColor.length ? t.localColor : this.globalColor), this.imgs.push(t);
  }
  getImgScreen() {
    const { stream: t } = this, e = {
      left: 0,
      right: 0,
      width: 0,
      height: 0,
      packageField: {
        localColorTableFlag: 0,
        interlaceFlag: 0,
        sortFlag: 0,
        unUse: 0,
        localColorTableSize: 0
      }
    };
    e.left = t.readUint16(), e.right = t.readUint16(), e.width = t.readUint16(), e.height = t.readUint16();
    let s = m(t.readUint8());
    return e.packageField = {
      localColorTableFlag: parseInt(s[0], 2),
      interlaceFlag: parseInt(s[1], 2),
      sortFlag: parseInt(s[2], 2),
      unUse: parseInt(s.slice(3, 5), 2),
      localColorTableSize: parseInt(s.slice(5, 8), 2)
    }, e;
  }
  getPlainText() {
    const { stream: t } = this;
    let e = t.readUint8(), s = "";
    for (; e; )
      s += String.fromCharCode(t.readUint8()), e--;
    return s;
  }
  getGraphControl() {
    const { stream: t } = this, e = {
      dataSize: 0,
      packageField: {
        unUse: 0,
        disposalMethod: 0,
        userInputFlag: 0,
        transparentColorFlag: 0
      },
      delayTime: 0,
      transparentColorIndex: 0
    };
    e.dataSize = t.readUint8();
    const s = m(t.readUint8());
    return e.packageField = {
      unUse: parseInt(s.slice(0, 3), 2),
      disposalMethod: parseInt(s.slice(3, 6), 2),
      userInputFlag: parseInt(s[6], 2),
      transparentColorFlag: parseInt(s[7], 2)
    }, e.delayTime = t.readUint16(), e.transparentColorIndex = t.readUint8(), e;
  }
  getComment() {
    const { stream: t } = this;
    let e = t.readUint8(), s = "";
    for (; e; )
      s += String.fromCharCode(t.readUint8()), e--;
    return s;
  }
  getApplication() {
    const { stream: t } = this;
    let e = t.readUint8(), s = "";
    for (; e; )
      s += String.fromCharCode(t.readUint8()), e--;
    let a = t.readUint8();
    for (; a; )
      t.readUint8(), a--;
    return s;
  }
  getImgData(t, e) {
    const { stream: s } = this, a = [], d = s.readUint8();
    let h = s.readUint8(), f = [];
    for (; h; )
      f.push(s.slice(s.offset, h)), s.setOffset(s.offset + h), h = s.readUint8();
    const c = new O();
    let o = [], i = [];
    const C = 1 << d, U = (1 << d) + 1;
    let p = d + 1, u = !1;
    return f.forEach((y) => {
      c.setBytes(y);
      let F = (1 << p) - 1;
      for (; c.hasBits(p); ) {
        let g = c.readBits(p);
        if (g === U) {
          o.push(g);
          break;
        } else if (g === C) {
          o = [], i = [];
          for (let n = 0; n <= U; n++)
            i[n] = n < C ? [n] : [];
          u = !1;
        } else if (!u)
          a.push(...i[g]), u = !0;
        else {
          let n = o[o.length - 1], b = 0;
          g <= i.length - 1 ? (a.push(...i[g]), b = i[g][0]) : (b = i[n][0], a.push(...i[n], b)), i.length - 1 < 4095 && (i.push([...i[n], b]), i.length - 1 === F && i.length - 1 < 4095 && (p++, F = (1 << p) - 1));
        }
        o.push(g);
      }
    }), this.handleImg(t, e, a);
  }
  handleImg(t, e, s) {
    const { width: a, height: d } = t, h = document.createElement("canvas");
    h.width = a, h.height = d;
    const f = h.getContext("2d"), c = f == null ? void 0 : f.createImageData(a, d), o = c == null ? void 0 : c.data;
    for (let i = 0; i < s.length; i++)
      o[i * 4 + 0] = e[s[i]][0], o[i * 4 + 1] = e[s[i]][1], o[i * 4 + 2] = e[s[i]][2], o[i * 4 + 3] = 255;
    return c;
  }
  getColor(t, e) {
    const { stream: s } = this;
    return t ? this.getColorTable(s, (2 << e) * 3) : [];
  }
  getColorTable(t, e) {
    const s = [];
    for (; e; ) {
      const a = [t.readUint8(), t.readUint8(), t.readUint8()];
      s.push(a), e -= 3;
    }
    return s;
  }
}
fetch("http://cloudstorage.ihubin.com/blog/audio-video/blog-17/rainbow.gif").then((r) => r.arrayBuffer()).then((r) => new DataView(r)).then((r) => {
  console.log(new k(r));
});
export {
  k as default
};
